{
  "sksl": {
    "entrypoint": "PistonswithMotionBlur_fragment_main",
    "shader": "// This SkSL shader is autogenerated by spirv-cross.\n\nfloat4 flutter_FragCoord;\n\nconst vec2 _1347[16] = vec2[](vec2(0.5625), vec2(0.4375, 0.3125), vec2(0.3125, 0.625), vec2(0.75, 0.4375), vec2(0.1875, 0.375), vec2(0.625, 0.8125), vec2(0.8125, 0.6875), vec2(0.6875, 0.1875), vec2(0.375, 0.875), vec2(0.5, 0.0625), vec2(0.25, 0.125), vec2(0.125, 0.25), vec2(0.0, 0.5), vec2(0.9375, 0.25), vec2(0.875, 0.9375), vec2(0.0625, 0.0));\n\nstruct TraceResult\n{\n    bool hit;\n    vec3 point;\n    vec3 incoming;\n};\n\n\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float iFrame;\nuniform vec4 iMouse;\nuniform vec4 iChannelWrap;\nuniform vec4 iChannelFilter;\nuniform vec2 iChannelResolution0;\nuniform vec2 iChannelResolution1;\nuniform vec2 iChannelResolution2;\nuniform vec2 iChannelResolution3;\nuniform float iTimeDelta;\nuniform shader iChannel0;\nuniform half2 iChannel0_size;\nuniform shader iChannel1;\nuniform half2 iChannel1_size;\n\nvec4 fragColor;\n\nvec2 FLT_flutter_local_FlutterFragCoord()\n{\n    return flutter_FragCoord.xy;\n}\n\nvec3 FLT_flutter_local_bluenoise(vec2 coord)\n{\n    return iChannel1.eval(iChannel1_size * ( coord / vec2(1024.0))).xyz;\n}\n\nvec2 FLT_flutter_local_coordToUv(vec2 coord)\n{\n    return (coord - (iResolution * 0.5)) / vec2(iResolution.y);\n}\n\nmat2 FLT_flutter_local_rotate(float a)\n{\n    float y = sin(a);\n    float x = cos(a);\n    return mat2(vec2(x, -y), vec2(y, x));\n}\n\nvec3 FLT_flutter_local_cameraRay(vec2 uv, vec3 position, vec3 lookAt, float zoom)\n{\n    vec3 forward = normalize(lookAt - position);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 lensPlane = forward * zoom;\n    vec3 lensPoint = (lensPlane + (right * uv.x)) + (up * uv.y);\n    vec3 direction = normalize(lensPoint);\n    return direction;\n}\n\nvec2 FLT_flutter_local_boxIntersect(vec3 ro, vec3 rd, vec3 rad)\n{\n    vec3 m = vec3(1.0) / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * rad;\n    vec3 t1 = (-n) - k;\n    vec3 t2 = (-n) + k;\n    return vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));\n}\n\nfloat FLT_flutter_local_getCamAngle(float initialAngle, float worldTime)\n{\n    return initialAngle + ((worldTime * min(worldTime, 32.0)) * 1.0);\n}\n\nvec3 FLT_flutter_local_erot(vec3 point, vec3 axis, float angle)\n{\n    return mix(axis * dot(axis, point), point, vec3(cos(angle))) + (cross(axis, point) * sin(angle));\n}\n\nfloat FLT_flutter_local_roundConeDistance(vec3 point, float radiusA, float radiusB, float height)\n{\n    vec2 q = vec2(length(point.xy), point.z);\n    float b = (radiusA - radiusB) / height;\n    float a = sqrt(1.0 - (b * b));\n    float k = dot(q, vec2(-b, a));\n    if (k < 0.0)\n    {\n        return length(q) - radiusA;\n    }\n    if (k > (a * height))\n    {\n        return length(q - vec2(0.0, height)) - radiusB;\n    }\n    return dot(q, vec2(a, b)) - radiusA;\n}\n\nfloat FLT_flutter_local_boxDistance(vec3 point, vec3 position, vec3 extents)\n{\n    vec3 adjustedPoint = point - position;\n    vec3 p = abs(adjustedPoint) - extents;\n    return length(max(p, vec3(0.0))) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat FLT_flutter_local_opSmoothIntersection(float a, float b, float k)\n{\n    float h = clamp(0.5 - ((0.5 * (b - a)) / k), 0.0, 1.0);\n    return mix(b, a, h) + ((k * h) * (1.0 - h));\n}\n\nfloat FLT_flutter_local_cylinderDistance(vec3 point, float height, float radius)\n{\n    vec2 d = abs(vec2(length(point.xz), point.y)) - vec2(radius, height);\n    return min(max(d.x, d.y), 0.0) + length(max(d, vec2(0.0)));\n}\n\nfloat FLT_flutter_local_smoothCylinderDistance(vec3 point, float height, float radius, float smoothing)\n{\n    vec3 param = point;\n    float param_1 = height - smoothing;\n    float param_2 = radius - smoothing;\n    return FLT_flutter_local_cylinderDistance(param, param_1, param_2) - smoothing;\n}\n\nfloat FLT_flutter_local_opSmoothUnion(float a, float b, float k)\n{\n    float h = clamp(0.5 + ((0.5 * (b - a)) / k), 0.0, 1.0);\n    return mix(b, a, h) - ((k * h) * (1.0 - h));\n}\n\nfloat FLT_flutter_local_segmentDistance(vec3 point, vec3 a, vec3 b)\n{\n    vec3 aToPoint = point - a;\n    vec3 aToB = b - a;\n    float time = clamp(dot(aToPoint, aToB) / dot(aToB, aToB), 0.0, 1.0);\n    return distance(point, a + (aToB * time));\n}\n\nfloat FLT_flutter_local_opSmoothSubtraction(float a, float b, float k)\n{\n    float h = clamp(0.5 - ((0.5 * (b + a)) / k), 0.0, 1.0);\n    return mix(b, -a, h) + ((k * h) * (1.0 - h));\n}\n\nfloat FLT_flutter_local_partDistance(inout vec3 point, float initialAngle, float worldTime)\n{\n    point = vec3(point.x, abs(point.z) - 0.100000001490116119384765625, point.y);\n    vec3 flattenedPoint = vec3(point.x, 0.0, point.z);\n    float smoothing = 0.0199999995529651641845703125;\n    float radiusA = 0.300000011920928955078125;\n    float radiusB = 0.1500000059604644775390625;\n    float size = 0.37999999523162841796875;\n    float param = initialAngle;\n    float param_1 = worldTime;\n    float camAngle = FLT_flutter_local_getCamAngle(param, param_1);\n    vec3 param_2 = flattenedPoint;\n    vec3 param_3 = vec3(0.0, 1.0, 0.0);\n    float param_4 = camAngle;\n    vec3 rotatedPoint = FLT_flutter_local_erot(param_2, param_3, param_4);\n    vec3 param_5 = rotatedPoint;\n    float param_6 = radiusA;\n    float param_7 = radiusB;\n    float param_8 = size;\n    float dist = FLT_flutter_local_roundConeDistance(param_5, param_6, param_7, param_8);\n    float halfHeight = 0.0500000007450580596923828125;\n    vec3 param_9 = point;\n    vec3 param_10 = vec3(0.0, halfHeight, 0.0);\n    vec3 param_11 = vec3(2.0, halfHeight, 2.0);\n    float container = FLT_flutter_local_boxDistance(param_9, param_10, param_11);\n    float param_12 = dist;\n    float param_13 = container;\n    float param_14 = smoothing;\n    dist = FLT_flutter_local_opSmoothIntersection(param_12, param_13, param_14);\n    vec3 postPoint = point - vec3(0.0, 0.1500000059604644775390625, 0.0);\n    vec3 param_15 = postPoint;\n    float param_16 = 0.100000001490116119384765625;\n    float param_17 = 0.093000002205371856689453125;\n    float param_18 = smoothing;\n    float post = FLT_flutter_local_smoothCylinderDistance(param_15, param_16, param_17, param_18);\n    float param_19 = dist;\n    float param_20 = post;\n    float param_21 = 0.00999999977648258209228515625;\n    dist = FLT_flutter_local_opSmoothUnion(param_19, param_20, param_21);\n    vec3 param_22 = vec3(0.0, 0.0, 0.37999999523162841796875);\n    vec3 param_23 = vec3(0.0, -1.0, 0.0);\n    float param_24 = camAngle;\n    vec3 camAttachment = FLT_flutter_local_erot(param_22, param_23, param_24);\n    vec3 jointPoint = point - camAttachment;\n    vec3 param_25 = jointPoint;\n    float param_26 = 0.07500000298023223876953125;\n    float param_27 = 0.093000002205371856689453125;\n    float param_28 = smoothing;\n    float joint = FLT_flutter_local_smoothCylinderDistance(param_25, param_26, param_27, param_28);\n    float param_29 = dist;\n    float param_30 = joint;\n    float param_31 = 0.004999999888241291046142578125;\n    dist = FLT_flutter_local_opSmoothUnion(param_29, param_30, param_31);\n    float rodX = 0.5;\n    float rodLength = 1.0;\n    vec3 rodEnd = vec3(0.0, 0.0, (rodLength + camAttachment.z) - 0.100000001490116119384765625);\n    vec3 rodPoint = vec3(point.x, 0.0, point.z);\n    vec3 param_32 = rodPoint;\n    vec3 param_33 = camAttachment;\n    vec3 param_34 = rodEnd;\n    float rod = FLT_flutter_local_segmentDistance(param_32, param_33, param_34) - 0.100000001490116119384765625;\n    vec3 param_35 = point;\n    vec3 param_36 = vec3(0.0, -0.100000001490116119384765625, 0.0);\n    vec3 param_37 = vec3(2.0, halfHeight, 2.0);\n    float rodContainer = FLT_flutter_local_boxDistance(param_35, param_36, param_37);\n    vec3 rodBasePoint = (point - camAttachment) - vec3(0.0, -0.100000001490116119384765625, 0.0);\n    vec3 param_38 = rodBasePoint;\n    float param_39 = halfHeight;\n    float param_40 = 0.20000000298023223876953125;\n    float param_41 = smoothing;\n    float rodBase = FLT_flutter_local_smoothCylinderDistance(param_38, param_39, param_40, param_41);\n    float param_42 = rod;\n    float param_43 = rodContainer;\n    float param_44 = smoothing;\n    float param_45 = FLT_flutter_local_opSmoothIntersection(param_42, param_43, param_44);\n    float param_46 = rodBase;\n    float param_47 = 0.07500000298023223876953125;\n    float rodComposite = FLT_flutter_local_opSmoothUnion(param_45, param_46, param_47);\n    dist = min(dist, rodComposite);\n    vec3 headPoint = vec3(point.x, (point.z - camAttachment.z) - rodLength, point.y + 0.100000001490116119384765625);\n    vec3 param_48 = headPoint;\n    float param_49 = 0.25;\n    float param_50 = 0.25;\n    float param_51 = smoothing;\n    float head = FLT_flutter_local_smoothCylinderDistance(param_48, param_49, param_50, param_51);\n    vec3 skirtPoint = point - vec3(0.0, 0.0, camAttachment.z + 0.64999997615814208984375);\n    vec3 param_52 = skirtPoint;\n    float param_53 = 0.25;\n    float param_54 = 0.20000000298023223876953125;\n    float skirtCut = FLT_flutter_local_cylinderDistance(param_52, param_53, param_54);\n    vec3 wristPoint = point - vec3(0.0, 0.1500000059604644775390625, camAttachment.z + 0.949999988079071044921875);\n    vec3 param_55 = wristPoint;\n    float param_56 = 0.100000001490116119384765625;\n    float param_57 = 0.0500000007450580596923828125;\n    float wristCut = FLT_flutter_local_cylinderDistance(param_55, param_56, param_57);\n    float headCuts = min(skirtCut, wristCut);\n    float param_58 = headCuts;\n    float param_59 = head;\n    float param_60 = 0.00999999977648258209228515625;\n    float headComposite = FLT_flutter_local_opSmoothSubtraction(param_58, param_59, param_60);\n    dist = min(dist, headComposite);\n    return dist;\n}\n\nfloat FLT_flutter_local_sceneDistance(vec3 point, float worldTime)\n{\n    float center = (floor(point.z * 1.7999999523162841796875) + 0.5) / 1.7999999523162841796875;\n    float neighborCenter = center + ((point.z < center) ? (-1.0) : 1.0);\n    vec3 param = point - vec3(0.0, 0.0, center);\n    float param_1 = 3.141590118408203125 * floor(center);\n    float param_2 = worldTime;\n    float _780 = FLT_flutter_local_partDistance(param, param_1, param_2);\n    float me = _780;\n    vec3 param_3 = point;\n    vec3 param_4 = vec3(0.0, 0.60000002384185791015625, neighborCenter);\n    vec3 param_5 = vec3(0.60000002384185791015625, 1.2000000476837158203125, 0.699999988079071044921875);\n    float neighbor = FLT_flutter_local_boxDistance(param_3, param_4, param_5);\n    float partComposite = min(me, neighbor);\n    vec3 param_6 = point;\n    vec3 param_7 = vec3(0.0, 0.60000002384185791015625, 0.560000002384185791015625);\n    vec3 param_8 = vec3(1.0, 1.39999997615814208984375, 1.10000002384185791015625);\n    float container = FLT_flutter_local_boxDistance(param_6, param_7, param_8);\n    float param_9 = partComposite;\n    float param_10 = container;\n    float param_11 = 0.0199999995529651641845703125;\n    return FLT_flutter_local_opSmoothIntersection(param_9, param_10, param_11);\n}\n\nTraceResult FLT_flutter_local_sceneTrace(vec3 origin, vec3 direction, float worldTime)\n{\n    bool hit = false;\n    float time = 0.0;\n    float tfar = 6.0;\n    vec3 param = origin - vec3(0.0, 0.449999988079071044921875, 0.550000011920928955078125);\n    vec3 param_1 = direction;\n    vec3 param_2 = vec3(0.60000002384185791015625, 1.2000000476837158203125, 1.14999997615814208984375);\n    vec2 bounds = FLT_flutter_local_boxIntersect(param, param_1, param_2);\n    bool _966 = bounds.x < bounds.y;\n    bool _972;\n    if (_966)\n    {\n        _972 = bounds.y > 0.0;\n    }\n    else\n    {\n        _972 = _966;\n    }\n    vec3 testPoint;\n    if (_972)\n    {\n        time = max(time, bounds.x);\n        tfar = min(tfar, bounds.y);\n        for (int i = 0; i < 128; i++)\n        {\n            testPoint = origin + (direction * time);\n            vec3 param_3 = testPoint;\n            float param_4 = worldTime;\n            float dist = FLT_flutter_local_sceneDistance(param_3, param_4);\n            if (dist < 9.9999997473787516355514526367188e-05)\n            {\n                hit = true;\n                break;\n            }\n            time += dist;\n            if (time > tfar)\n            {\n                break;\n            }\n        }\n    }\n    return TraceResult(hit, testPoint, direction);\n}\n\nvec2 FLT_flutter_local_equirectangularMap(vec3 d)\n{\n    float x = atan(d.y, d.x);\n    float y = acos(clamp(d.z, -1.0, 1.0));\n    return vec2((x / 6.283185482025146484375) + 0.5, y / 3.1415927410125732421875);\n}\n\nvec3 FLT_flutter_local_skyColor(vec3 direction)\n{\n    vec3 param = direction;\n    vec2 uv = FLT_flutter_local_equirectangularMap(param);\n    return iChannel0.eval(iChannel0_size * ( uv)).xyz;\n}\n\nvec3 FLT_flutter_local_sceneNormal(vec3 point, float worldTime)\n{\n    vec3 n = vec3(0.0);\n    int _825 = int(min(iFrame, 0.0));\n    for (int i = _825; i < 4; i++)\n    {\n        vec3 e = ((vec3(float(((i + 3) >> 1) & 1), float((i >> 1) & 1), float(i & 1)) * 2.0) - vec3(1.0)) * 0.577300012111663818359375;\n        vec3 param = point + (e * 0.0005000000237487256526947021484375);\n        float param_1 = worldTime;\n        n += (e * FLT_flutter_local_sceneDistance(param, param_1));\n    }\n    return normalize(n);\n}\n\nfloat FLT_flutter_local_sceneOcclusion(vec3 point, vec3 normal, float worldTime)\n{\n    float dist = 0.039999999105930328369140625;\n    float occlusion = 1.0;\n    for (int index = 0; index < 3; index++)\n    {\n        vec3 param = point + (normal * dist);\n        float param_1 = worldTime;\n        occlusion = min(occlusion, FLT_flutter_local_sceneDistance(param, param_1) / dist);\n        dist *= 0.800000011920928955078125;\n    }\n    return max(occlusion, 0.0500000007450580596923828125);\n}\n\nvec3 FLT_flutter_local_sceneColor(vec2 uv, float worldTime)\n{\n    bool _1084 = iMouse.x > 20.0;\n    bool _1090;\n    if (_1084)\n    {\n        _1090 = iMouse.y > 20.0;\n    }\n    else\n    {\n        _1090 = _1084;\n    }\n    vec2 _1091;\n    if (_1090)\n    {\n        _1091 = iMouse.xy / iResolution;\n    }\n    else\n    {\n        _1091 = vec2(0.4000000059604644775390625, 0.5);\n    }\n    vec2 mouse = _1091;\n    vec3 initialOrigin = vec3(0.0, 3.0, -3.0);\n    float param = ((-mouse.y) * 3.1400001049041748046875) + 1.0;\n    vec3 _1116 = initialOrigin;\n    vec2 _1118 = _1116.yz * FLT_flutter_local_rotate(param);\n    initialOrigin.y = _1118.x;\n    initialOrigin.z = _1118.y;\n    float param_1 = (-mouse.x) * 6.283100128173828125;\n    vec3 _1130 = initialOrigin;\n    vec2 _1132 = _1130.xz * FLT_flutter_local_rotate(param_1);\n    initialOrigin.x = _1132.x;\n    initialOrigin.z = _1132.y;\n    vec2 param_2 = uv;\n    vec3 param_3 = initialOrigin;\n    vec3 param_4 = vec3(0.0, 0.550000011920928955078125, 0.60000002384185791015625);\n    float param_5 = 1.4500000476837158203125;\n    vec3 initialDirection = FLT_flutter_local_cameraRay(param_2, param_3, param_4, param_5);\n    vec3 origin = initialOrigin;\n    vec3 direction = initialDirection;\n    vec3 color = vec3(1.0);\n    bool completedAllBounces = true;\n    for (int b = 0; b < 2; b++)\n    {\n        vec3 param_6 = origin;\n        vec3 param_7 = direction;\n        float param_8 = worldTime;\n        TraceResult res = FLT_flutter_local_sceneTrace(param_6, param_7, param_8);\n        if (!res.hit)\n        {\n            vec3 param_9 = res.incoming;\n            color = (color * FLT_flutter_local_skyColor(param_9)) * 2.0;\n            completedAllBounces = false;\n            break;\n        }\n        vec3 param_10 = res.point;\n        float param_11 = worldTime;\n        vec3 normal = FLT_flutter_local_sceneNormal(param_10, param_11);\n        if (b == 0)\n        {\n            vec3 param_12 = res.point;\n            vec3 param_13 = normal;\n            float param_14 = worldTime;\n            color *= FLT_flutter_local_sceneOcclusion(param_12, param_13, param_14);\n        }\n        color *= 0.5;\n        direction = reflect(direction, normal);\n        origin = res.point + (direction * 0.001000000047497451305389404296875);\n    }\n    if (completedAllBounces)\n    {\n        vec3 param_15 = direction;\n        return color * FLT_flutter_local_skyColor(param_15);\n    }\n    return color;\n}\n\nvec3 FLT_flutter_local_temporalSample(vec2 coord, float worldTime)\n{\n    float shutterTime = iTimeDelta;\n    int sampleCount = 16;\n    float slice = shutterTime / float(sampleCount);\n    vec2 param = coord;\n    vec3 jitter = FLT_flutter_local_bluenoise(param);\n    vec3 color = vec3(0.0);\n    float _1297;\n    for (int sampleIndex = 0; sampleIndex < sampleCount; sampleIndex++)\n    {\n        float jitterTime = (float(sampleIndex) + 1.0) + (iFrame + 1.0);\n        vec3 adjustedJitter = fract(jitter + vec3(jitterTime * 0.61803400516510009765625));\n        float t = float(sampleIndex) / float(sampleCount);\n        if (false)\n        {\n            _1297 = (worldTime - shutterTime) + (adjustedJitter.z * shutterTime);\n        }\n        else\n        {\n            _1297 = worldTime - (shutterTime * t);\n        }\n        float sampleTime = _1297;\n        vec2 offset = _1347[sampleIndex % 16];\n        vec2 param_1 = coord + offset;\n        vec2 uv = FLT_flutter_local_coordToUv(param_1);\n        vec2 param_2 = uv;\n        float param_3 = sampleTime;\n        color += FLT_flutter_local_sceneColor(param_2, param_3);\n    }\n    return color / vec3(float(sampleCount));\n}\n\nvec3 FLT_flutter_local_hejl(vec3 color, float whitePoint)\n{\n    vec4 vh = vec4(color, whitePoint);\n    vec4 va = (vh * 1.4249999523162841796875) + vec4(0.0500000007450580596923828125);\n    vec4 vf = (((vh * va) + vec4(0.0040000001899898052215576171875)) / ((vh * (va + vec4(0.550000011920928955078125))) + vec4(0.0491000004112720489501953125))) - vec4(0.082099996507167816162109375);\n    return vf.xyz / vf.www;\n}\n\nvoid FLT_flutter_local_mainImage(out vec4 fragColor_1, vec2 fragCoord)\n{\n    vec2 param = fragCoord;\n    float param_1 = iTime;\n    vec3 color = FLT_flutter_local_temporalSample(param, param_1);\n    vec3 param_2 = color;\n    float param_3 = 1.0;\n    vec3 toneMapped = FLT_flutter_local_hejl(param_2, param_3);\n    vec3 gammaCorrected = pow(toneMapped, vec3(0.4545454680919647216796875));\n    fragColor_1 = vec4(gammaCorrected, 1.0);\n}\n\nvoid FLT_main()\n{\n    float keep = (((((((((((iFrame + iMouse.x) + iTime) + iResolution.x) + iChannelWrap.x) + iChannelResolution0.x) + iChannelResolution0.y) + iChannelResolution1.x) + iChannelResolution1.y) + iChannelResolution2.x) + iChannelResolution2.y) + iChannelResolution3.x) + iChannelResolution3.y;\n    vec2 fragCoord_1 = FLT_flutter_local_FlutterFragCoord();\n    vec2 param_5 = fragCoord_1;\n    vec4 param_4;\n    FLT_flutter_local_mainImage(param_4, param_5);\n    fragColor = param_4;\n    if (keep < (-100000002004087734272.0))\n    {\n        fragColor += vec4(keep);\n    }\n}\n\nhalf4 main(float2 iFragCoord)\n{\n      flutter_FragCoord = float4(iFragCoord, 0, 0);\n      FLT_main();\n      return fragColor;\n}\n",
    "stage": 1,
    "uniforms": [
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 0,
        "name": "iResolution",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 1,
        "name": "iTime",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 2,
        "name": "iFrame",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 3,
        "name": "iMouse",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 4,
        "name": "iChannelWrap",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 5,
        "name": "iChannelFilter",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 6,
        "name": "iChannelResolution0",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 7,
        "name": "iChannelResolution1",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 8,
        "name": "iChannelResolution2",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 9,
        "name": "iChannelResolution3",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 0,
        "columns": 1,
        "location": 10,
        "name": "iChannel0",
        "rows": 1,
        "type": 12
      },
      {
        "array_elements": 0,
        "bit_width": 0,
        "columns": 1,
        "location": 11,
        "name": "iChannel1",
        "rows": 1,
        "type": 12
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 12,
        "name": "iTimeDelta",
        "rows": 1,
        "type": 10
      }
    ]
  }
}