{
  "sksl": {
    "entrypoint": "drifting_fragment_main",
    "shader": "// This SkSL shader is autogenerated by spirv-cross.\n\nfloat4 flutter_FragCoord;\n\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float iFrame;\nuniform vec4 iMouse;\nuniform vec4 iChannelWrap;\nuniform vec4 iChannelFilter;\nuniform vec2 iChannelResolution0;\nuniform vec2 iChannelResolution1;\nuniform vec2 iChannelResolution2;\nuniform vec2 iChannelResolution3;\n\nvec4 fragColor;\n\nvec2 FLT_flutter_local_FlutterFragCoord()\n{\n    return flutter_FragCoord.xy;\n}\n\nmat3 FLT_flutter_local_rotate_angle_axis(vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(vec3(((oc * axis.x) * axis.x) + c, ((oc * axis.x) * axis.y) - (axis.z * s), ((oc * axis.z) * axis.x) + (axis.y * s)), vec3(((oc * axis.x) * axis.y) + (axis.z * s), ((oc * axis.y) * axis.y) + c, ((oc * axis.y) * axis.z) - (axis.x * s)), vec3(((oc * axis.z) * axis.x) - (axis.y * s), ((oc * axis.y) * axis.z) + (axis.x * s), ((oc * axis.z) * axis.z) + c));\n}\n\nfloat FLT_flutter_local_sphere_intersect(vec3 p, vec3 d, float R)\n{\n    vec3 v = p - vec3(0.0, -6360000.0, 0.0);\n    float b = dot(v, d);\n    float c = dot(v, v) - (R * R);\n    float det2 = (b * b) - c;\n    if (det2 < 0.0)\n    {\n        return -1.0;\n    }\n    float det = sqrt(det2);\n    float t1 = (-b) - det;\n    float t2 = (-b) + det;\n    return (t1 >= 0.0) ? t1 : t2;\n}\n\nvoid FLT_flutter_local_calculate_particle_densities(vec3 pos, out float rayleigh, out float mie)\n{\n    float h = length(pos - vec3(0.0, -6360000.0, 0.0)) - 6360000.0;\n    rayleigh = exp((-h) / 8000.0);\n    mie = exp((-h) / 1300.0) + 0.100000001490116119384765625;\n}\n\nvoid FLT_flutter_local_scatter(vec3 ro, vec3 rd, vec3 lp, inout vec3 col, inout vec3 scat, float t)\n{\n    vec3 mie_constant = vec3(2.0999999833293259143829345703125e-05);\n    vec3 rayleigh_constant = vec3(5.8000000535685103386640548706055e-06, 1.3500000022759195417165756225586e-05, 3.3100001019192859530448913574219e-05);\n    vec3 param = ro;\n    vec3 param_1 = rd;\n    float param_2 = 6380000.0;\n    float L = FLT_flutter_local_sphere_intersect(param, param_1, param_2);\n    float mu = dot(rd, lp);\n    float opmu2 = 1.0 + (mu * mu);\n    float rayleigh_phase = 0.05968309938907623291015625 * opmu2;\n    float mie_phase = (0.00472690165042877197265625 * opmu2) / (2.960400104522705078125 * pow(1.96039998531341552734375 - (1.96000003814697265625 * mu), 1.5));\n    float sun_phase = (0.00011936620285268872976303100585938 * opmu2) / (2.999000072479248046875 * pow(1.99899995326995849609375 - (1.99800002574920654296875 * mu), 1.5));\n    float depth_rayleigh = 0.0;\n    float depth_mie = 0.0;\n    vec3 R = vec3(0.0);\n    vec3 M = vec3(0.0);\n    float view_step_size = L / 64.0;\n    float param_4;\n    float param_5;\n    float param_10;\n    float param_11;\n    for (int i = 0; i < 64; i++)\n    {\n        float l = float(i) * view_step_size;\n        vec3 sample_p_view = ro + (rd * l);\n        vec3 param_3 = sample_p_view;\n        FLT_flutter_local_calculate_particle_densities(param_3, param_4, param_5);\n        float density_rayleigh = param_4;\n        float density_mie = param_5;\n        density_rayleigh *= view_step_size;\n        density_mie *= view_step_size;\n        depth_rayleigh += density_rayleigh;\n        depth_mie += density_mie;\n        vec3 param_6 = sample_p_view;\n        vec3 param_7 = lp;\n        float param_8 = 6380000.0;\n        float to_light_isect = FLT_flutter_local_sphere_intersect(param_6, param_7, param_8);\n        if (to_light_isect > 0.0)\n        {\n            float light_step_size = to_light_isect / 32.0;\n            float depth_rayleigh_light = 0.0;\n            float depth_mie_light = 0.0;\n            for (int j = 0; j < 32; j++)\n            {\n                float ls = float(j) * light_step_size;\n                vec3 sample_p_light = sample_p_view + (lp * ls);\n                vec3 param_9 = sample_p_light;\n                FLT_flutter_local_calculate_particle_densities(param_9, param_10, param_11);\n                float density_rayleigh_light = param_10;\n                float density_mie_light = param_11;\n                depth_rayleigh_light += (density_rayleigh_light * light_step_size);\n                depth_mie_light += (density_mie_light * light_step_size);\n            }\n            vec3 absorption = exp(-((rayleigh_constant * (depth_rayleigh_light + depth_rayleigh)) + (mie_constant * (depth_mie_light + depth_mie))));\n            R += (absorption * density_rayleigh);\n            M += (absorption * density_mie);\n        }\n    }\n    col = ((M * 25.0) * mie_constant) * mie_phase;\n    col += (((R * 25.0) * rayleigh_constant) * rayleigh_phase);\n    col += (((M * 8.0) * mie_constant) * sun_phase);\n    scat = (mie_constant * 0.00999999977648258209228515625) * depth_mie;\n}\n\nfloat FLT_flutter_local_hash21(inout vec2 p)\n{\n    p = fract(p * vec2(123.339996337890625, 234.339996337890625));\n    p += vec2(dot(p, p + vec2(23.43000030517578125)));\n    return fract(p.x * p.y);\n}\n\nfloat FLT_flutter_local_star_layer(vec2 p, float seed)\n{\n    float t = (iTime * 2.0) + seed;\n    vec2 id = floor(p);\n    vec2 gv = fract(p) - vec2(0.5);\n    vec2 param = id;\n    float _845 = FLT_flutter_local_hash21(param);\n    float n = _845;\n    float x = fract(n * 12.31999969482421875);\n    float y = fract(n * 123.31999969482421875);\n    vec2 offs = vec2(x, y) - vec2(0.5);\n    float d = length(gv - (offs * 0.89999997615814208984375));\n    float m = smoothstep(0.00999999977648258209228515625, 0.0, d);\n    m *= pow((sin(t + (n * 6.283199787139892578125)) * 0.5) + 0.5, 3.0);\n    return m;\n}\n\nfloat FLT_flutter_local_plane_intersect(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{\n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 999999.0);\n}\n\nvec2 FLT_flutter_local_wave_dx(vec2 position, vec2 direction, float frequency, float timeshift)\n{\n    float x = (dot(direction, position) * frequency) + timeshift;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat FLT_flutter_local_calculate_wave_at_p(inout vec2 position, int iterations)\n{\n    float iter = 0.0;\n    float frequency = 1.0;\n    float time_mult = 2.0;\n    float weight = 1.0;\n    float sum_of_values = 0.0;\n    float sum_of_weights = 0.0;\n    for (int i = 0; i < iterations; i++)\n    {\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 param = position;\n        vec2 param_1 = p;\n        float param_2 = frequency;\n        float param_3 = iTime * time_mult;\n        vec2 wave_data = FLT_flutter_local_wave_dx(param, param_1, param_2, param_3);\n        position += (((p * wave_data.y) * weight) * 0.37999999523162841796875);\n        sum_of_values += (wave_data.x * weight);\n        sum_of_weights += weight;\n        weight = mix(weight, 0.0, 0.20000000298023223876953125);\n        frequency *= 1.17999994754791259765625;\n        time_mult *= 1.07000005245208740234375;\n        iter += 1232.39990234375;\n    }\n    return sum_of_values / sum_of_weights;\n}\n\nfloat FLT_flutter_local_march(vec3 camera, vec3 start, vec3 end, float depth)\n{\n    vec3 p = start;\n    vec3 dir = normalize(end - start);\n    for (int i = 0; i < 64; i++)\n    {\n        vec2 param = p.xz;\n        int param_1 = 32;\n        float _718 = FLT_flutter_local_calculate_wave_at_p(param, param_1);\n        float wave_height = (_718 * depth) - depth;\n        if ((wave_height + 0.100000001490116119384765625) > p.y)\n        {\n            return distance(p, camera);\n        }\n        p += (dir * (p.y - wave_height));\n    }\n    return distance(start, camera);\n}\n\nvec3 FLT_flutter_local_normal(vec2 p, float e, float depth)\n{\n    vec2 ex = vec2(e, 0.0);\n    vec2 param = p;\n    int param_1 = 32;\n    float _756 = FLT_flutter_local_calculate_wave_at_p(param, param_1);\n    float wave_height = _756 * depth;\n    vec3 a = vec3(p.x, wave_height, p.y);\n    vec2 param_2 = p - ex;\n    int param_3 = 32;\n    float _776 = FLT_flutter_local_calculate_wave_at_p(param_2, param_3);\n    vec2 param_4 = p + ex.yx;\n    int param_5 = 32;\n    float _792 = FLT_flutter_local_calculate_wave_at_p(param_4, param_5);\n    return normalize(cross(a - vec3(p.x - e, _776 * depth, p.y), a - vec3(p.x, _792 * depth, p.y + e)));\n}\n\nvec3 FLT_flutter_local_render(vec2 uv)\n{\n    vec2 mouse = (iMouse.xy - (iResolution * 0.5)) / vec2(iResolution.y);\n    float aspect = iResolution.x / iResolution.y;\n    bool _909 = iMouse.x == 0.0;\n    bool _915;\n    if (_909)\n    {\n        _915 = iMouse.y == 0.0;\n    }\n    else\n    {\n        _915 = _909;\n    }\n    if (_915)\n    {\n        mouse = vec2(0.0, -0.100000001490116119384765625);\n    }\n    float fov_rads = 1.73205077648162841796875;\n    float x = ((sin(iTime * 0.5) + cos(iTime * 0.5)) * 0.5) + 0.5;\n    vec3 _934;\n    if (true)\n    {\n        _934 = vec3(iTime * 0.100000001490116119384765625, mix(1.5, 0.5, x), 1.0);\n    }\n    else\n    {\n        _934 = vec3(iTime * 0.100000001490116119384765625, 1.5, 1.0);\n    }\n    vec3 ro = _934;\n    vec3 param = vec3(1.0, 0.0, 0.0);\n    float param_1 = -0.180000007152557373046875;\n    mat3 rot = FLT_flutter_local_rotate_angle_axis(param, param_1);\n    vec3 rd = rot * normalize(vec3(uv, fov_rads / (-2.5)));\n    vec3 _969;\n    if ((iMouse.z > 0.0) || true)\n    {\n        _969 = rot * normalize(vec3(mouse, fov_rads / (-2.5)));\n    }\n    else\n    {\n        _969 = rot * normalize(vec3(sin(iTime * 0.100000001490116119384765625) * 0.89999997615814208984375, cos(iTime * 0.100000001490116119384765625) * 0.89999997615814208984375, fov_rads / (-2.5)));\n    }\n    vec3 lp = _969;\n    if (rd.y >= 0.0)\n    {\n        vec3 sky_color = vec3(0.0);\n        vec3 sky_scattering = vec3(0.0);\n        vec3 param_2 = ro;\n        vec3 param_3 = rd;\n        vec3 param_4 = lp;\n        float param_7 = iTime;\n        vec3 param_5;\n        vec3 param_6;\n        FLT_flutter_local_scatter(param_2, param_3, param_4, param_5, param_6, param_7);\n        sky_color = param_5;\n        sky_scattering = param_6;\n        sky_color += sky_scattering;\n        float offset = dot(rd, vec3(10.0));\n        vec2 param_8 = uv * 10.0;\n        float param_9 = offset;\n        float stars = FLT_flutter_local_star_layer(param_8, param_9);\n        vec2 param_10 = (uv * 17.0) + vec2(3.099999904632568359375);\n        float param_11 = offset;\n        stars += FLT_flutter_local_star_layer(param_10, param_11);\n        vec2 param_12 = (uv * 23.0) + vec2(23.1000003814697265625);\n        float param_13 = offset;\n        stars += FLT_flutter_local_star_layer(param_12, param_13);\n        stars *= smoothstep(0.0, -0.20000000298023223876953125, lp.y);\n        return sky_color + vec3(stars);\n    }\n    vec3 water_plane_high = vec3(0.0);\n    vec3 water_plane_low = vec3(0.0, -1.0, 0.0);\n    vec3 param_14 = ro;\n    vec3 param_15 = rd;\n    vec3 param_16 = water_plane_high;\n    vec3 param_17 = vec3(0.0, 1.0, 0.0);\n    float high_plane_hit = FLT_flutter_local_plane_intersect(param_14, param_15, param_16, param_17);\n    vec3 param_18 = ro;\n    vec3 param_19 = rd;\n    vec3 param_20 = water_plane_low;\n    vec3 param_21 = vec3(0.0, 1.0, 0.0);\n    float low_plane_hit = FLT_flutter_local_plane_intersect(param_18, param_19, param_20, param_21);\n    vec3 high_hit_p = ro + (rd * high_plane_hit);\n    vec3 low_hit_p = ro + (rd * low_plane_hit);\n    vec3 param_22 = ro;\n    vec3 param_23 = high_hit_p;\n    vec3 param_24 = low_hit_p;\n    float param_25 = 1.0;\n    float d = FLT_flutter_local_march(param_22, param_23, param_24, param_25);\n    vec3 water_hit_p = ro + (rd * d);\n    vec2 param_26 = water_hit_p.xz;\n    float param_27 = 0.00999999977648258209228515625;\n    float param_28 = 1.0;\n    vec3 N = FLT_flutter_local_normal(param_26, param_27, param_28);\n    N = mix(N, vec3(0.0, 1.0, 0.0), vec3(0.87999999523162841796875 * min(1.0, sqrt(d * 0.00999999977648258209228515625) * 0.89999997615814208984375)));\n    vec3 L = normalize(lp);\n    vec3 V = normalize(-rd);\n    vec3 H = normalize(L + V);\n    float NdotH = dot(N, H);\n    float fresnel = 0.039999999105930328369140625 + (0.959999978542327880859375 * pow(1.0 - max(0.0, dot(-N, rd)), 8.0));\n    float k = 0.0;\n    float tan_a = length(cross(N, H)) / NdotH;\n    float cos_a = NdotH;\n    float m2 = 0.96039998531341552734375;\n    float tana2 = tan_a * tan_a;\n    float cosa4 = pow(abs(cos_a), 4.0);\n    k = (exp((-tana2) / m2) / ((3.1415927410125732421875 * m2) * cosa4)) * 0.100000001490116119384765625;\n    float diff = max(0.0, dot(N, L));\n    vec3 sss = vec3(0.0029299999587237834930419921875, 0.00698000006377696990966796875, 0.0171700008213520050048828125) * (1.0 + ((water_hit_p.y + 1.0) / 1.0));\n    vec3 R = normalize(reflect(rd, N));\n    R.y = abs(R.y);\n    vec3 water_reflect = vec3(0.0);\n    vec3 water_scat = vec3(0.0);\n    vec3 param_29 = ro;\n    vec3 param_30 = R;\n    vec3 param_31 = lp;\n    float param_34 = iTime;\n    vec3 param_32;\n    vec3 param_33;\n    FLT_flutter_local_scatter(param_29, param_30, param_31, param_32, param_33, param_34);\n    water_reflect = param_32;\n    water_scat = param_33;\n    water_reflect += water_scat;\n    vec3 diffuse_scatter = (water_scat + sss) * diff;\n    vec3 spec_reflection = (water_reflect * k) + (water_reflect * fresnel);\n    float offset_1 = dot(rd * d, vec3(10.0));\n    vec2 param_35 = rd.xz * 10.0;\n    float param_36 = offset_1;\n    float stars_1 = FLT_flutter_local_star_layer(param_35, param_36);\n    vec2 param_37 = (rd.xz * 17.0) + vec2(3.099999904632568359375);\n    float param_38 = offset_1;\n    stars_1 += FLT_flutter_local_star_layer(param_37, param_38);\n    vec2 param_39 = (rd.xz * 23.0) + vec2(23.1000003814697265625);\n    float param_40 = offset_1;\n    stars_1 += FLT_flutter_local_star_layer(param_39, param_40);\n    stars_1 *= smoothstep(0.0, -0.20000000298023223876953125, lp.y);\n    return (spec_reflection + diffuse_scatter) + vec3(stars_1 * 0.100000001490116119384765625);\n}\n\nvec3 FLT_flutter_local_aces_tonemap(vec3 color)\n{\n    mat3 m1 = mat3(vec3(0.59719002246856689453125, 0.075999997556209564208984375, 0.0284000001847743988037109375), vec3(0.354579985141754150390625, 0.908339977264404296875, 0.13382999598979949951171875), vec3(0.048229999840259552001953125, 0.0156599991023540496826171875, 0.837769985198974609375));\n    mat3 m2 = mat3(vec3(1.60475003719329833984375, -0.10208000242710113525390625, -0.00326999998651444911956787109375), vec3(-0.5310800075531005859375, 1.108129978179931640625, -0.07276000082492828369140625), vec3(-0.0736699998378753662109375, -0.00604999996721744537353515625, 1.0760200023651123046875));\n    vec3 v = m1 * color;\n    vec3 a = (v * (v + vec3(0.02457859925925731658935546875))) - vec3(9.0537003416102379560470581054688e-05);\n    vec3 b = (v * ((v * 0.98372900485992431640625) + vec3(0.4329510033130645751953125))) + vec3(0.23808099329471588134765625);\n    return pow(clamp(m2 * (a / b), vec3(0.0), vec3(1.0)), vec3(0.4545454680919647216796875));\n}\n\nvoid FLT_flutter_local_mainImage(out vec4 fragColor_1, vec2 fragCoord)\n{\n    vec3 tot = vec3(0.0);\n    vec2 p = (fragCoord - (iResolution * 0.5)) / vec2(iResolution.y);\n    vec2 param = p;\n    vec3 color = FLT_flutter_local_render(param);\n    vec3 param_1 = color;\n    color = FLT_flutter_local_aces_tonemap(param_1);\n    tot += color;\n    fragColor_1 = vec4(tot, 1.0);\n}\n\nvoid FLT_main()\n{\n    float keep = (((((((((((iFrame + iMouse.x) + iTime) + iResolution.x) + iChannelWrap.x) + iChannelResolution0.x) + iChannelResolution0.y) + iChannelResolution1.x) + iChannelResolution1.y) + iChannelResolution2.x) + iChannelResolution2.y) + iChannelResolution3.x) + iChannelResolution3.y;\n    vec2 fragCoord_1 = FLT_flutter_local_FlutterFragCoord();\n    vec2 param_3 = fragCoord_1;\n    vec4 param_2;\n    FLT_flutter_local_mainImage(param_2, param_3);\n    fragColor = param_2;\n    if (keep < (-100000002004087734272.0))\n    {\n        fragColor += vec4(keep);\n    }\n}\n\nhalf4 main(float2 iFragCoord)\n{\n      flutter_FragCoord = float4(iFragCoord, 0, 0);\n      FLT_main();\n      return fragColor;\n}\n",
    "stage": 1,
    "uniforms": [
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 0,
        "name": "iResolution",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 1,
        "name": "iTime",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 2,
        "name": "iFrame",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 3,
        "name": "iMouse",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 4,
        "name": "iChannelWrap",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 5,
        "name": "iChannelFilter",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 6,
        "name": "iChannelResolution0",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 7,
        "name": "iChannelResolution1",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 8,
        "name": "iChannelResolution2",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 9,
        "name": "iChannelResolution3",
        "rows": 2,
        "type": 10
      }
    ]
  }
}