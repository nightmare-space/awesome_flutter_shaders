{
  "sksl": {
    "entrypoint": "WheretheRiverGoes_fragment_main",
    "shader": "// This SkSL shader is autogenerated by spirv-cross.\n\nfloat4 flutter_FragCoord;\n\nstruct Intersection\n{\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n\nstruct Surface\n{\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n\n\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float iFrame;\nuniform vec4 iMouse;\nuniform vec4 iChannelWrap;\nuniform vec4 iChannelFilter;\nuniform vec2 iChannelResolution0;\nuniform vec2 iChannelResolution1;\nuniform vec2 iChannelResolution2;\nuniform vec2 iChannelResolution3;\nuniform shader iChannel0;\nuniform half2 iChannel0_size;\n\nvec4 fragColor;\n\nfloat g_fTime;\n\nvec2 FLT_flutter_local_FlutterFragCoord()\n{\n    return flutter_FragCoord.xy;\n}\n\nfloat FLT_flutter_local_GetRiverMeander(float x)\n{\n    return sin(x * 0.300000011920928955078125) * 1.5;\n}\n\nfloat FLT_flutter_local_Hash(float p)\n{\n    vec2 p2 = fract(vec2(p) * vec2(4.438974857330322265625, 3.9729731082916259765625));\n    p2 += vec2(dot(p2.yx, p2 + vec2(19.1900005340576171875)));\n    return fract(p2.x * p2.y);\n}\n\nfloat FLT_flutter_local_SmoothNoise(vec2 o)\n{\n    vec2 p = floor(o);\n    vec2 f = fract(o);\n    float n = p.x + (p.y * 57.0);\n    float param = n + 0.0;\n    float a = FLT_flutter_local_Hash(param);\n    float param_1 = n + 1.0;\n    float b = FLT_flutter_local_Hash(param_1);\n    float param_2 = n + 57.0;\n    float c = FLT_flutter_local_Hash(param_2);\n    float param_3 = n + 58.0;\n    float d = FLT_flutter_local_Hash(param_3);\n    vec2 f2 = f * f;\n    vec2 f3 = f2 * f;\n    vec2 t = (f2 * 3.0) - (f3 * 2.0);\n    float u = t.x;\n    float v = t.y;\n    float res = ((a + ((b - a) * u)) + ((c - a) * v)) + (((((a - b) + d) - c) * u) * v);\n    return res;\n}\n\nfloat FLT_flutter_local_FBM_Simple(inout vec2 p, float ps)\n{\n    float f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for (int i = 0; i < 3; i++)\n    {\n        vec2 param = p;\n        f += (FLT_flutter_local_SmoothNoise(param) * a);\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat FLT_flutter_local_GetRiverBedOffset(vec3 vPos)\n{\n    float fRiverBedDepth = 0.300000011920928955078125 + ((0.5 + (0.5 * sin((vPos.x * 0.001000000047497451305389404296875) + 3.0))) * 0.4000000059604644775390625);\n    float fRiverBedWidth = 2.0 + (cos(vPos.x * 0.100000001490116119384765625) * 1.0);\n    float fRiverBedAmount = smoothstep(fRiverBedWidth, fRiverBedWidth * 0.5, abs(vPos.z - FLT_flutter_local_GetRiverMeander(vPos.x)));\n    return fRiverBedAmount * fRiverBedDepth;\n}\n\nfloat FLT_flutter_local_GetTerrainHeightSimple(vec3 vPos)\n{\n    vec2 param = vPos.xz * vec2(0.5, 1.0);\n    float param_1 = 0.5;\n    float _711 = FLT_flutter_local_FBM_Simple(param, param_1);\n    float fbm = _711;\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight -= FLT_flutter_local_GetRiverBedOffset(vPos);\n    return fTerrainHeight;\n}\n\nvec2 FLT_flutter_local_GetWindowCoord(vec2 vUV)\n{\n    vec2 vWindow = (vUV * 2.0) - vec2(1.0);\n    vWindow.x *= (iResolution.x / iResolution.y);\n    return vWindow;\n}\n\nvec3 FLT_flutter_local_GetCameraRayDir(vec2 vWindow, vec3 vCameraPos, vec3 vCameraTarget)\n{\n    vec3 vForward = normalize(vCameraTarget - vCameraPos);\n    vec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n    vec3 vUp = normalize(cross(vForward, vRight));\n    vec3 vDir = normalize(((vRight * vWindow.x) + (vUp * vWindow.y)) + (vForward * 2.0));\n    return vDir;\n}\n\nfloat FLT_flutter_local_FBM(inout vec2 p, float ps)\n{\n    float f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for (int i = 0; i < 3; i++)\n    {\n        vec2 param = p;\n        f += (FLT_flutter_local_SmoothNoise(param) * a);\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\nfloat FLT_flutter_local_GetTerrainHeight(vec3 vPos)\n{\n    vec2 param = vPos.xz * vec2(0.5, 1.0);\n    float param_1 = 0.5;\n    float _695 = FLT_flutter_local_FBM(param, param_1);\n    float fbm = _695;\n    float fTerrainHeight = fbm * fbm;\n    fTerrainHeight -= FLT_flutter_local_GetRiverBedOffset(vPos);\n    return fTerrainHeight;\n}\n\nfloat FLT_flutter_local_GetSceneDistance(vec3 vPos)\n{\n    return vPos.y - FLT_flutter_local_GetTerrainHeight(vPos);\n}\n\nvoid FLT_flutter_local_RaymarchScene(vec3 vRayOrigin, vec3 vRayDir, inout Intersection intersection)\n{\n    float stepScale = 1.0;\n    vec2 vRayProfile = vec2(sqrt(dot(vRayDir.xz, vRayDir.xz)), vRayDir.y);\n    vec2 vGradVec = vec2(0.447213590145111083984375, 0.89442718029022216796875);\n    vec2 vGradPerp = vec2(vGradVec.y, -vGradVec.x);\n    float fRdotG = dot(vRayProfile, vGradPerp);\n    float fOdotG = dot(vec2(0.0, 1.0), vGradPerp);\n    stepScale = (-fOdotG) / fRdotG;\n    if (stepScale < 0.0)\n    {\n        intersection.m_objId = 0.0;\n        intersection.m_dist = 20.0;\n        return;\n    }\n    intersection.m_dist = 0.00999999977648258209228515625;\n    intersection.m_objId = 0.0;\n    float fSceneDist = 0.0;\n    float oldT = 0.00999999977648258209228515625;\n    for (int iter = 0; iter < 64; iter++)\n    {\n        vec3 vPos = vRayOrigin + (vRayDir * intersection.m_dist);\n        if (vRayDir.y > 0.0)\n        {\n            if (vPos.y > 1.0)\n            {\n                intersection.m_objId = 0.0;\n                intersection.m_dist = 20.0;\n                break;\n            }\n        }\n        fSceneDist = FLT_flutter_local_GetSceneDistance(vPos);\n        oldT = intersection.m_dist;\n        intersection.m_dist += (fSceneDist * stepScale);\n        intersection.m_objId = 1.0;\n        if (fSceneDist <= 0.00999999977648258209228515625)\n        {\n            break;\n        }\n        if (intersection.m_dist > 20.0)\n        {\n            intersection.m_objId = 0.0;\n            intersection.m_dist = 20.0;\n            break;\n        }\n    }\n    intersection.m_pos = vRayOrigin + (vRayDir * intersection.m_dist);\n}\n\nvec3 FLT_flutter_local_GetSunDir()\n{\n    return vec3(-0.80257236957550048828125, 0.561800658702850341796875, 0.2006430923938751220703125);\n}\n\nvec3 FLT_flutter_local_GetSkyColour(vec3 vRayDir)\n{\n    vec3 vSkyColour = mix(vec3(0.60000002384185791015625, 3.0, 6.0), vec3(0.4000000059604644775390625, 2.0, 4.0), vec3(clamp(vRayDir.y, 0.0, 1.0)));\n    float fSunDotV = dot(FLT_flutter_local_GetSunDir(), vRayDir);\n    float fDirDot = clamp((fSunDotV * 0.5) + 0.5, 0.0, 1.0);\n    vSkyColour += ((vec3(5.0, 4.25, 2.5) * (1.0 - exp2(fDirDot * (-0.5)))) * 2.0);\n    return vSkyColour;\n}\n\nvoid FLT_flutter_local_TraceWater(vec3 vRayOrigin, vec3 vRayDir, inout Intersection intersection)\n{\n    intersection.m_dist = 20.0;\n    float t = (-vRayOrigin.y) / vRayDir.y;\n    if (t > 0.0)\n    {\n        intersection.m_dist = t;\n    }\n    intersection.m_pos = vRayOrigin + (vRayDir * intersection.m_dist);\n}\n\nfloat FLT_flutter_local_GetRiverMeanderDx(float x)\n{\n    return (cos(x * 0.300000011920928955078125) * 1.5) * 0.300000011920928955078125;\n}\n\nvec2 FLT_flutter_local_GetBaseFlow(vec2 vPos)\n{\n    return vec2(1.0, FLT_flutter_local_GetRiverMeanderDx(vPos.x));\n}\n\nfloat FLT_flutter_local_GetFlowDistance(vec2 vPos)\n{\n    return -FLT_flutter_local_GetTerrainHeightSimple(vec3(vPos.x, 0.0, vPos.y));\n}\n\nvec2 FLT_flutter_local_GetGradient(vec2 vPos)\n{\n    vec2 vDelta = vec2(0.00999999977648258209228515625, 0.0);\n    float dx = FLT_flutter_local_GetFlowDistance(vPos + vDelta) - FLT_flutter_local_GetFlowDistance(vPos - vDelta);\n    float dy = FLT_flutter_local_GetFlowDistance(vPos + vDelta.yx) - FLT_flutter_local_GetFlowDistance(vPos - vDelta.yx);\n    return vec2(dx, dy);\n}\n\nvec3 FLT_flutter_local_GetFlowRate(vec2 vPos)\n{\n    vec2 vBaseFlow = FLT_flutter_local_GetBaseFlow(vPos);\n    vec2 vFlow = vBaseFlow;\n    float fFoam = 0.0;\n    float fDepth = -FLT_flutter_local_GetTerrainHeightSimple(vec3(vPos.x, 0.0, vPos.y));\n    float fDist = FLT_flutter_local_GetFlowDistance(vPos);\n    vec2 vGradient = FLT_flutter_local_GetGradient(vPos);\n    vFlow += (((-vGradient) * 40.0) / vec2(1.0 + (fDist * 1.5)));\n    vFlow *= (1.0 / (1.0 + (fDist * 0.5)));\n    float fBehindObstacle = 0.5 - (dot(normalize(vGradient), -normalize(vFlow)) * 0.5);\n    float fSlowDist = clamp(fDepth * 5.0, 0.0, 1.0);\n    fSlowDist = mix((fSlowDist * 0.89999997615814208984375) + 0.100000001490116119384765625, 1.0, fBehindObstacle * 0.89999997615814208984375);\n    fSlowDist = 0.5 + (fSlowDist * 0.5);\n    vFlow *= fSlowDist;\n    float fFoamScale1 = 0.5;\n    float fFoamCutoff = 0.4000000059604644775390625;\n    float fFoamScale2 = 0.3499999940395355224609375;\n    fFoam = abs(length(vFlow)) * fFoamScale1;\n    fFoam += clamp(fFoam - fFoamCutoff, 0.0, 1.0);\n    fFoam = 1.0 - pow(fDist, fFoam * fFoamScale2);\n    return vec3(vFlow * 0.60000002384185791015625, fFoam);\n}\n\nvec2 FLT_flutter_local_Hash2(float p)\n{\n    vec3 p3 = fract(vec3(p) * vec3(0.103100001811981201171875, 0.10300000011920928955078125, 0.097300000488758087158203125));\n    p3 += vec3(dot(p3, p3.yzx + vec3(19.1900005340576171875)));\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 FLT_flutter_local_sg_dFdx(vec2 v)\n{\n    return vec2(0.0);\n}\n\nvec2 FLT_flutter_local_sg_dFdy(vec2 v)\n{\n    return vec2(0.0);\n}\n\nvec3 FLT_flutter_local_SmoothNoise_DXY(vec2 o)\n{\n    vec2 p = floor(o);\n    vec2 f = fract(o);\n    float n = p.x + (p.y * 57.0);\n    float param = n + 0.0;\n    float a = FLT_flutter_local_Hash(param);\n    float param_1 = n + 1.0;\n    float b = FLT_flutter_local_Hash(param_1);\n    float param_2 = n + 57.0;\n    float c = FLT_flutter_local_Hash(param_2);\n    float param_3 = n + 58.0;\n    float d = FLT_flutter_local_Hash(param_3);\n    vec2 f2 = f * f;\n    vec2 f3 = f2 * f;\n    vec2 t = (f2 * 3.0) - (f3 * 2.0);\n    vec2 dt = (f * 6.0) - (f2 * 6.0);\n    float u = t.x;\n    float v = t.y;\n    float du = dt.x;\n    float dv = dt.y;\n    float res = ((a + ((b - a) * u)) + ((c - a) * v)) + (((((a - b) + d) - c) * u) * v);\n    float dx = ((b - a) * du) + (((((a - b) + d) - c) * du) * v);\n    float dy = ((c - a) * dv) + (((((a - b) + d) - c) * u) * dv);\n    return vec3(dx, dy, res);\n}\n\nvec3 FLT_flutter_local_FBM_DXY(inout vec2 p, inout vec2 flow, float ps, float df)\n{\n    vec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    for (int i = 0; i < 4; i++)\n    {\n        p += flow;\n        flow *= (-0.75);\n        vec2 param = p;\n        vec3 v = FLT_flutter_local_SmoothNoise_DXY(param);\n        f += (v * a);\n        p += (v.xy * df);\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / vec3(tot);\n}\n\nvec4 FLT_flutter_local_SampleWaterNormal(vec2 vUV, vec2 vFlowOffset, float fMag, float fFoam)\n{\n    vec2 param = vUV;\n    vec2 param_1 = vUV;\n    vec2 vFilterWidth = max(abs(FLT_flutter_local_sg_dFdx(param)), abs(FLT_flutter_local_sg_dFdy(param_1)));\n    float fFilterWidth = max(vFilterWidth.x, vFilterWidth.y);\n    float fScale = 1.0 / (1.0 + ((fFilterWidth * fFilterWidth) * 2000.0));\n    float fGradientAscent = 0.25 + (fFoam * (-1.5));\n    vec2 param_2 = vUV * 20.0;\n    vec2 param_3 = vFlowOffset * 20.0;\n    float param_4 = 0.75 + (fFoam * 0.25);\n    float param_5 = fGradientAscent;\n    vec3 _899 = FLT_flutter_local_FBM_DXY(param_2, param_3, param_4, param_5);\n    vec3 dxy = _899;\n    fScale *= max(0.25, 1.0 - (fFoam * 5.0));\n    vec3 vBlended = mix(vec3(0.0, 1.0, 0.0), normalize(vec3(dxy.x, fMag, dxy.y)), vec3(fScale));\n    return vec4(normalize(vBlended), dxy.z * fScale);\n}\n\nfloat FLT_flutter_local_SampleWaterFoam(vec2 vUV, vec2 vFlowOffset, float fFoam)\n{\n    vec2 param = vUV * 30.0;\n    vec2 param_1 = vFlowOffset * 50.0;\n    float param_2 = 0.800000011920928955078125;\n    float param_3 = -0.5;\n    vec3 _943 = FLT_flutter_local_FBM_DXY(param, param_1, param_2, param_3);\n    float f = _943.z;\n    float fAmount = 0.20000000298023223876953125;\n    f = max(0.0, (f - fAmount) / fAmount);\n    return pow(0.5, f);\n}\n\nvec4 FLT_flutter_local_SampleFlowingNormal(vec2 vUV, vec2 vFlowRate, float fFoam, float time, out float fOutFoamTex)\n{\n    float fMag = 2.5 / (1.0 + (dot(vFlowRate, vFlowRate) * 5.0));\n    float t0 = fract(time);\n    float t1 = fract(time + 0.5);\n    float i0 = floor(time);\n    float i1 = floor(time + 0.5);\n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    float param = i0;\n    vec2 vUV0 = vUV + FLT_flutter_local_Hash2(param);\n    float param_1 = i1;\n    vec2 vUV1 = vUV + FLT_flutter_local_Hash2(param_1);\n    vec2 param_2 = vUV0;\n    vec2 param_3 = vFlowRate * o0;\n    float param_4 = fMag;\n    float param_5 = fFoam;\n    vec4 sample0 = FLT_flutter_local_SampleWaterNormal(param_2, param_3, param_4, param_5);\n    vec2 param_6 = vUV1;\n    vec2 param_7 = vFlowRate * o1;\n    float param_8 = fMag;\n    float param_9 = fFoam;\n    vec4 sample1 = FLT_flutter_local_SampleWaterNormal(param_6, param_7, param_8, param_9);\n    float weight = abs(t0 - 0.5) * 2.0;\n    vec2 param_10 = vUV0;\n    vec2 param_11 = (vFlowRate * o0) * 0.25;\n    float param_12 = fFoam;\n    float foam0 = FLT_flutter_local_SampleWaterFoam(param_10, param_11, param_12);\n    vec2 param_13 = vUV1;\n    vec2 param_14 = (vFlowRate * o1) * 0.25;\n    float param_15 = fFoam;\n    float foam1 = FLT_flutter_local_SampleWaterFoam(param_13, param_14, param_15);\n    vec4 result = mix(sample0, sample1, vec4(weight));\n    vec4 _1038 = result;\n    vec3 _1040 = normalize(_1038.xyz);\n    result.x = _1040.x;\n    result.y = _1040.y;\n    result.z = _1040.z;\n    fOutFoamTex = mix(foam0, foam1, weight);\n    return result;\n}\n\nvec3 FLT_flutter_local_GetSceneNormal(vec3 vPos)\n{\n    vec3 vDir1 = vec3(1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0, 1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n    vec3 vOffset1 = vDir1 * 0.001000000047497451305389404296875;\n    vec3 vOffset2 = vDir2 * 0.001000000047497451305389404296875;\n    vec3 vOffset3 = vDir3 * 0.001000000047497451305389404296875;\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n    float f1 = FLT_flutter_local_GetSceneDistance(vPos1);\n    float f2 = FLT_flutter_local_GetSceneDistance(vPos2);\n    float f3 = FLT_flutter_local_GetSceneDistance(vPos3);\n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    vec3 vNormal = cross(vPos1 - vPos2, vPos3 - vPos2);\n    return normalize(vNormal);\n}\n\nvoid FLT_flutter_local_GetSurfaceInfo(Intersection intersection, inout Surface surface)\n{\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = FLT_flutter_local_GetSceneNormal(intersection.m_pos);\n    vec3 vWeights = surface.m_normal * surface.m_normal;\n    vec3 col = vec3(0.0);\n    vec3 _sample = iChannel0.eval(iChannel0_size * ( intersection.m_pos.xz)).xyz;\n    col += ((_sample * _sample) * vWeights.y);\n    _sample = iChannel0.eval(iChannel0_size * ( intersection.m_pos.xy)).xyz;\n    col += ((_sample * _sample) * vWeights.z);\n    _sample = iChannel0.eval(iChannel0_size * ( intersection.m_pos.yz)).xyz;\n    col += ((_sample * _sample) * vWeights.x);\n    col /= vec3((vWeights.x + vWeights.y) + vWeights.z);\n    surface.m_albedo = col;\n    surface.m_specR0 = vec3(0.001000000047497451305389404296875);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n\nfloat FLT_flutter_local_GIV(float dotNV, float k)\n{\n    return 1.0 / (((dotNV + 9.9999997473787516355514526367188e-05) * (1.0 - k)) + k);\n}\n\nvoid FLT_flutter_local_AddSunLight(Surface surf, vec3 vViewDir, float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular)\n{\n    vec3 vSunDir = FLT_flutter_local_GetSunDir();\n    vec3 vH = normalize(vViewDir + vSunDir);\n    float fNdotL = clamp(dot(FLT_flutter_local_GetSunDir(), surf.m_normal), 0.0, 1.0);\n    float fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n    float fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    float diffuseIntensity = fNdotL;\n    vDiffuse += ((vec3(5.0, 4.25, 2.5) * diffuseIntensity) * fShadowFactor);\n    float alpha = 1.0 - surf.m_gloss;\n    float alphaSqr = alpha * alpha;\n    float pi = 3.141590118408203125;\n    float denom = ((fNdotH * fNdotH) * (alphaSqr - 1.0)) + 1.0;\n    float d = alphaSqr / ((pi * denom) * denom);\n    float k = alpha / 2.0;\n    float param = fNdotL;\n    float param_1 = k;\n    float param_2 = fNdotV;\n    float param_3 = k;\n    float vis = FLT_flutter_local_GIV(param, param_1) * FLT_flutter_local_GIV(param_2, param_3);\n    float fSpecularIntensity = (d * vis) * fNdotL;\n    vSpecular += ((vec3(5.0, 4.25, 2.5) * fSpecularIntensity) * fShadowFactor);\n}\n\nvoid FLT_flutter_local_AddSkyLight(Surface surf, inout vec3 vDiffuse, vec3 vSpecular)\n{\n    float skyIntensity = max(0.0, (surf.m_normal.y * 0.300000011920928955078125) + 0.699999988079071044921875);\n    vDiffuse += (vec3(0.100000001490116119384765625, 0.5, 1.0) * skyIntensity);\n}\n\nvec3 FLT_flutter_local_GetRayColour(vec3 vRayOrigin, vec3 vRayDir, inout Intersection intersection)\n{\n    vec3 param = vRayOrigin;\n    vec3 param_1 = vRayDir;\n    Intersection param_2;\n    FLT_flutter_local_RaymarchScene(param, param_1, param_2);\n    intersection = param_2;\n    if (intersection.m_objId == 0.0)\n    {\n        vec3 param_3 = vRayDir;\n        return FLT_flutter_local_GetSkyColour(param_3);\n    }\n    Intersection param_4 = intersection;\n    Surface param_5;\n    FLT_flutter_local_GetSurfaceInfo(param_4, param_5);\n    Surface surface = param_5;\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    Surface param_6 = surface;\n    vec3 param_7 = vResult;\n    vec3 param_8 = vIgnore;\n    FLT_flutter_local_AddSunLight(param_6, -vRayDir, fSunShadow, param_7, param_8);\n    vResult = param_7;\n    vIgnore = param_8;\n    Surface param_9 = surface;\n    vec3 param_10 = vResult;\n    vec3 param_11 = vIgnore;\n    FLT_flutter_local_AddSkyLight(param_9, param_10, param_11);\n    vResult = param_10;\n    vIgnore = param_11;\n    return vResult * surface.m_albedo;\n}\n\nvec3 FLT_flutter_local_GetWaterExtinction(float dist)\n{\n    float fOpticalDepth = dist * 6.0;\n    vec3 vExtinctCol = vec3(0.5, 0.60000002384185791015625, 0.89999997615814208984375);\n    vec3 vExtinction = exp2(vExtinctCol * (-fOpticalDepth));\n    return vExtinction;\n}\n\nfloat FLT_flutter_local_GetSunShadow(vec3 vPos)\n{\n    vec3 vSunDir = FLT_flutter_local_GetSunDir();\n    float k_fShadowDist = 2.0;\n    vec3 param = vPos + (vSunDir * k_fShadowDist);\n    vec3 param_1 = -vSunDir;\n    Intersection param_2;\n    FLT_flutter_local_RaymarchScene(param, param_1, param_2);\n    Intersection shadowInt = param_2;\n    float fShadowFactor = 1.0;\n    if (shadowInt.m_dist < (k_fShadowDist - 0.100000001490116119384765625))\n    {\n        fShadowFactor = 0.0;\n    }\n    return fShadowFactor;\n}\n\nvec3 FLT_flutter_local_GetRayColour(vec3 vRayOrigin, vec3 vRayDir)\n{\n    Intersection param;\n    vec3 _1675 = FLT_flutter_local_GetRayColour(vRayOrigin, vRayDir, param);\n    Intersection intersection = param;\n    return _1675;\n}\n\nvec3 FLT_flutter_local_GetEnvColour(vec3 vRayDir, float fGloss)\n{\n    return mix(vec3(0.300000011920928955078125, 0.20000000298023223876953125, 0.20000000298023223876953125), vec3(0.4000000059604644775390625, 2.0, 4.0), vec3(clamp(((vRayDir.y * (1.0 - (fGloss * 0.5))) * 0.5) + 0.5, 0.0, 1.0)));\n}\n\nvec3 FLT_flutter_local_GetFresnel(vec3 vView, vec3 vNormal, vec3 vR0, float fGloss)\n{\n    float NdotV = max(0.0, dot(vView, vNormal));\n    return vR0 + (((vec3(1.0) - vR0) * pow(1.0 - NdotV, 5.0)) * pow(fGloss, 20.0));\n}\n\nvec3 FLT_flutter_local_GetSceneColour(vec3 vRayOrigin, vec3 vRayDir)\n{\n    vec3 param = vRayOrigin;\n    vec3 param_1 = vRayDir;\n    Intersection param_2;\n    FLT_flutter_local_RaymarchScene(param, param_1, param_2);\n    Intersection primaryInt = param_2;\n    float fFogDistance = 0.0;\n    vec3 vResult = vec3(0.0);\n    float fSunDotV = dot(FLT_flutter_local_GetSunDir(), vRayDir);\n    if (primaryInt.m_objId == 0.0)\n    {\n        vec3 param_3 = vRayDir;\n        vResult = FLT_flutter_local_GetSkyColour(param_3);\n        fFogDistance = 20.0;\n    }\n    else\n    {\n        vec3 param_4 = vRayOrigin;\n        vec3 param_5 = vRayDir;\n        Intersection param_6;\n        FLT_flutter_local_TraceWater(param_4, param_5, param_6);\n        Intersection waterInt = param_6;\n        vec3 vSpecularLight = vec3(0.0);\n        vec3 vFlowRateAndFoam = FLT_flutter_local_GetFlowRate(waterInt.m_pos.xz);\n        vec2 vFlowRate = vFlowRateAndFoam.xy;\n        float fFoam = vFlowRateAndFoam.z;\n        float fFoamScale = 1.5;\n        float fFoamOffset = 0.20000000298023223876953125;\n        fFoam = clamp((fFoam - fFoamOffset) * fFoamScale, 0.0, 1.0);\n        fFoam = (fFoam * fFoam) * 0.5;\n        float fWaterFoamTex = 1.0;\n        float param_7;\n        vec4 _1739 = FLT_flutter_local_SampleFlowingNormal(waterInt.m_pos.xz, vFlowRate, fFoam, g_fTime, param_7);\n        fWaterFoamTex = param_7;\n        vec4 vWaterNormalAndHeight = _1739;\n        if (vRayDir.y < (-0.00999999977648258209228515625))\n        {\n            waterInt.m_dist -= ((0.039999999105930328369140625 * (1.0 - vWaterNormalAndHeight.w)) / vRayDir.y);\n        }\n        vec3 vReflectRayOrigin;\n        vec3 vSpecNormal;\n        Surface specSurface;\n        vec3 vTransmitLight;\n        if (waterInt.m_dist < primaryInt.m_dist)\n        {\n            fFogDistance = waterInt.m_dist;\n            vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n            vReflectRayOrigin = waterInt.m_pos;\n            vSpecNormal = vWaterNormal;\n            vec3 vRefractRayOrigin = waterInt.m_pos;\n            vec3 vRefractRayDir = refract(vRayDir, vWaterNormal, 0.750018775463104248046875);\n            Intersection param_8;\n            vec3 _1787 = FLT_flutter_local_GetRayColour(vRefractRayOrigin, vRefractRayDir, param_8);\n            Intersection refractInt = param_8;\n            vec3 vRefractLight = _1787;\n            float fEdgeAlpha = clamp((1.0 + (vWaterNormalAndHeight.w * 0.25)) - (refractInt.m_dist * 10.0), 0.0, 1.0);\n            fFoam *= (1.0 - fEdgeAlpha);\n            float param_9 = refractInt.m_dist + abs(refractInt.m_pos.y);\n            vec3 vExtinction = FLT_flutter_local_GetWaterExtinction(param_9);\n            specSurface.m_pos = waterInt.m_pos;\n            specSurface.m_normal = normalize(vWaterNormal + (FLT_flutter_local_GetSunDir() * fFoam));\n            specSurface.m_albedo = vec3(1.0);\n            specSurface.m_specR0 = vec3(0.00999999977648258209228515625);\n            vec2 param_10 = waterInt.m_pos.xz;\n            vec2 param_11 = waterInt.m_pos.xz;\n            vec2 vFilterWidth = max(abs(FLT_flutter_local_sg_dFdx(param_10)), abs(FLT_flutter_local_sg_dFdy(param_11)));\n            float fFilterWidth = max(vFilterWidth.x, vFilterWidth.y);\n            float fGlossFactor = exp2((-fFilterWidth) * 0.300000011920928955078125);\n            specSurface.m_gloss = 0.9900000095367431640625 * fGlossFactor;\n            specSurface.m_specScale = 1.0;\n            vec3 vSurfaceDiffuse = vec3(0.0);\n            float fSunShadow = 1.0;\n            fSunShadow = FLT_flutter_local_GetSunShadow(waterInt.m_pos);\n            Surface param_12 = specSurface;\n            vec3 param_13 = vSurfaceDiffuse;\n            vec3 param_14 = vSpecularLight;\n            FLT_flutter_local_AddSunLight(param_12, -vRayDir, fSunShadow, param_13, param_14);\n            vSurfaceDiffuse = param_13;\n            vSpecularLight = param_14;\n            Surface param_15 = specSurface;\n            vec3 param_16 = vSurfaceDiffuse;\n            vec3 param_17 = vSpecularLight;\n            FLT_flutter_local_AddSkyLight(param_15, param_16, param_17);\n            vSurfaceDiffuse = param_16;\n            vSpecularLight = param_17;\n            vec3 vInscatter = (vSurfaceDiffuse * (1.0 - exp((-refractInt.m_dist) * 0.100000001490116119384765625))) * (1.0 + fSunDotV);\n            vTransmitLight = vRefractLight;\n            vTransmitLight += vInscatter;\n            vTransmitLight *= vExtinction;\n            float fFoamBlend = 1.0 - pow(fWaterFoamTex, fFoam * 5.0);\n            vTransmitLight = mix(vTransmitLight, vSurfaceDiffuse * 0.800000011920928955078125, vec3(fFoamBlend));\n            specSurface.m_specScale = clamp(1.0 - (fFoamBlend * 4.0), 0.0, 1.0);\n        }\n        else\n        {\n            fFogDistance = primaryInt.m_dist;\n            Intersection param_18 = primaryInt;\n            Surface param_19;\n            FLT_flutter_local_GetSurfaceInfo(param_18, param_19);\n            Surface primarySurface = param_19;\n            vSpecNormal = primarySurface.m_normal;\n            vReflectRayOrigin = primaryInt.m_pos;\n            float fWetness = 1.0 - clamp((vReflectRayOrigin.y + 0.02500000037252902984619140625) * 5.0, 0.0, 1.0);\n            primarySurface.m_gloss = mix(primarySurface.m_albedo.x, 1.0, fWetness);\n            primarySurface.m_albedo = mix(primarySurface.m_albedo, primarySurface.m_albedo * 0.800000011920928955078125, vec3(fWetness));\n            vTransmitLight = vec3(0.0);\n            float fSunShadow_1 = 1.0;\n            Surface param_20 = primarySurface;\n            vec3 param_21 = vTransmitLight;\n            vec3 param_22 = vSpecularLight;\n            FLT_flutter_local_AddSunLight(param_20, -vRayDir, fSunShadow_1, param_21, param_22);\n            vTransmitLight = param_21;\n            vSpecularLight = param_22;\n            Surface param_23 = primarySurface;\n            vec3 param_24 = vTransmitLight;\n            vec3 param_25 = vSpecularLight;\n            FLT_flutter_local_AddSkyLight(param_23, param_24, param_25);\n            vTransmitLight = param_24;\n            vSpecularLight = param_25;\n            vTransmitLight *= primarySurface.m_albedo;\n            specSurface = primarySurface;\n        }\n        vec3 vReflectRayDir = reflect(vRayDir, vSpecNormal);\n        vec3 vReflectLight = FLT_flutter_local_GetRayColour(vReflectRayOrigin, vReflectRayDir);\n        vec3 param_26 = vReflectRayDir;\n        float param_27 = specSurface.m_gloss;\n        vReflectLight = mix(FLT_flutter_local_GetEnvColour(param_26, param_27), vReflectLight, vec3(pow(specSurface.m_gloss, 40.0)));\n        vec3 param_28 = -vRayDir;\n        vec3 param_29 = vSpecNormal;\n        vec3 param_30 = specSurface.m_specR0;\n        float param_31 = specSurface.m_gloss;\n        vec3 vFresnel = FLT_flutter_local_GetFresnel(param_28, param_29, param_30, param_31);\n        vSpecularLight += vReflectLight;\n        vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale);\n    }\n    if (fFogDistance >= 20.0)\n    {\n        fFogDistance = 100.0;\n        vResult = (vec3(5.0, 4.25, 2.5) * smoothstep(0.999499976634979248046875, 0.99989998340606689453125, fSunDotV)) * 200.0;\n    }\n    vec3 param_32 = vRayDir;\n    vec3 vFogColour = FLT_flutter_local_GetSkyColour(param_32);\n    vec3 vFogExtCol = exp2(vec3(0.02999999932944774627685546875, 0.04500000178813934326171875, 0.04500000178813934326171875) * (-fFogDistance));\n    vec3 vFogInCol = exp2(vec3(0.014999999664723873138427734375, 0.013500000350177288055419921875, 0.01200000010430812835693359375) * (-fFogDistance));\n    vResult = (vResult * vFogExtCol) + (vFogColour * (vec3(1.0) - vFogInCol));\n    return vResult;\n}\n\nvec3 FLT_flutter_local_ApplyVignetting(vec2 vUV, vec3 vInput)\n{\n    vec2 vOffset = (vUV - vec2(0.5)) * 1.41421353816986083984375;\n    float fDist = dot(vOffset, vOffset);\n    float fShade = mix(1.0, 0.20000000298023223876953125, fDist);\n    return vInput * fShade;\n}\n\nvec3 FLT_flutter_local_Tonemap(vec3 x)\n{\n    float a = 0.00999999977648258209228515625;\n    float b = 0.1319999992847442626953125;\n    float c = 0.00999999977648258209228515625;\n    float d = 0.16300000250339508056640625;\n    float e = 0.101000003516674041748046875;\n    return (x * ((x * a) + vec3(b))) / ((x * ((x * c) + vec3(d))) + vec3(e));\n}\n\nvoid FLT_flutter_local_mainImage(out vec4 fragColor_1, vec2 fragCoord)\n{\n    g_fTime = iTime;\n    float fBaseTime = iTime;\n    g_fTime = fBaseTime;\n    float fCameraTime = g_fTime;\n    vec2 vUV = fragCoord / iResolution;\n    vec3 vCameraTarget = vec3(0.0, -0.5, 0.0);\n    vCameraTarget.x -= (fCameraTime * 0.5);\n    vec3 vCameraPos = vCameraTarget + vec3(0.0);\n    float fHeading = fCameraTime * 0.100000001490116119384765625;\n    float fDist = 1.5 - (cos((fCameraTime * 0.100000001490116119384765625) + 2.0) * 0.800000011920928955078125);\n    if (iMouse.z > 0.0)\n    {\n        fHeading = (iMouse.x * 10.0) / iResolution.x;\n        fDist = 5.0 - ((iMouse.y * 5.0) / iResolution.y);\n    }\n    vCameraPos.y += (1.0 + ((fDist * fDist) * 0.00999999977648258209228515625));\n    vCameraPos.x += (sin(fHeading) * fDist);\n    vCameraPos.z += (cos(fHeading) * fDist);\n    vCameraTarget.z += FLT_flutter_local_GetRiverMeander(vCameraTarget.x);\n    vCameraPos.z += FLT_flutter_local_GetRiverMeander(vCameraPos.x);\n    vCameraPos.y = max(vCameraPos.y, FLT_flutter_local_GetTerrainHeightSimple(vCameraPos) + 0.20000000298023223876953125);\n    vec3 vRayOrigin = vCameraPos;\n    vec3 vRayDir = FLT_flutter_local_GetCameraRayDir(FLT_flutter_local_GetWindowCoord(vUV), vCameraPos, vCameraTarget);\n    vec3 vResult = FLT_flutter_local_GetSceneColour(vRayOrigin, vRayDir);\n    vResult = FLT_flutter_local_ApplyVignetting(vUV, vResult);\n    vec3 param = vResult * 3.0;\n    vec3 vFinal = FLT_flutter_local_Tonemap(param);\n    vFinal = (vFinal * 1.10000002384185791015625) - vec3(0.100000001490116119384765625);\n    fragColor_1 = vec4(vFinal, 1.0);\n}\n\nvoid FLT_main()\n{\n    float keep = (((((((((((iFrame + iMouse.x) + iTime) + iResolution.x) + iChannelWrap.x) + iChannelResolution0.x) + iChannelResolution0.y) + iChannelResolution1.x) + iChannelResolution1.y) + iChannelResolution2.x) + iChannelResolution2.y) + iChannelResolution3.x) + iChannelResolution3.y;\n    vec2 fragCoord_1 = FLT_flutter_local_FlutterFragCoord();\n    vec2 param_2 = fragCoord_1;\n    vec4 param_1;\n    FLT_flutter_local_mainImage(param_1, param_2);\n    fragColor = param_1;\n    if (keep < (-100000002004087734272.0))\n    {\n        fragColor += vec4(keep);\n    }\n}\n\nhalf4 main(float2 iFragCoord)\n{\n      flutter_FragCoord = float4(iFragCoord, 0, 0);\n      FLT_main();\n      return fragColor;\n}\n",
    "stage": 1,
    "uniforms": [
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 0,
        "name": "iResolution",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 1,
        "name": "iTime",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 2,
        "name": "iFrame",
        "rows": 1,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 3,
        "name": "iMouse",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 4,
        "name": "iChannelWrap",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 5,
        "name": "iChannelFilter",
        "rows": 4,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 6,
        "name": "iChannelResolution0",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 7,
        "name": "iChannelResolution1",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 8,
        "name": "iChannelResolution2",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 32,
        "columns": 1,
        "location": 9,
        "name": "iChannelResolution3",
        "rows": 2,
        "type": 10
      },
      {
        "array_elements": 0,
        "bit_width": 0,
        "columns": 1,
        "location": 10,
        "name": "iChannel0",
        "rows": 1,
        "type": 12
      }
    ]
  }
}